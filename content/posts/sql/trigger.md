---
weight: 3
title: "Mysql触发器的使用"
date: 2020-03-20T15:55:54+08:00
draft: false
categroies: ["sql"]
---


## Mysql触发器语法
```sql
DELIMITER //
CREATE TRIGGER [触发器的名字]
[触发器执行时机] [触发器监测的对象]
ON [表名] FOR EACH ROW 
[触发器主体代码]//
DELIMITER ;
```
触发器的结构包括:
1. `DELIMITER //`: Mysql默认分隔符是`;`, 但在触发器中, 我们使用`//`表示触发器的开始与结束. 也可以使用其他字符代替, 如`$$`等
2. `[触发器的名字]`: 定义触发器的名字, 可通过触发器的名字删除触发器.
3. `[触发器执行时机]`: 这里设置触发器是在关键动作执行之前触发还是执行之后. `BEFORE`or`AFTER`
4. `[触发器检测的操作]`: 触发器可以检测`INSERT` `UPDATE` `DELETE`的操作, 当检测到相关操作时,触发器就会被激活.
5. `[表名]`: 需要创建触发器的数据表名.
6. `FOR EACH ROW`: 带上这个参数后, 触发器将检测每一行对关联表操作的代码, 一旦符合条件, 触发器就会被触发
7. `[触发器主体代码]`: 这里可以是一句SQL语句, 也可以是当行. 如果是多行, 那么这些命令需要写在`BEGIN...END`之间.

例子:
```sql
DELIMITER // 
CREATE TRIGGER `can_not_follow_self` 
BEFORE INSERT ON follow FOR EACH ROW 
IF NEW.followed_user_id = NEW.following_user_id 
THEN SIGNAL SQLSTATE '45000'
SET MESSAGE_TEXT = "不能关注自己";
END IF//
DELIMITER;
```

以上代码当插入一条`followed_user_id = following_user_id`的记录时, 触发器会返回以下错误信息
```sql
THEN SIGNAL SQLSTATE '45000'
SET MESSAGE_TEXT = "不能关注自己";
```
>`NEW`  `OLD` <br>
> 在 `INSERT` 型触发器中，`NEW` 用来表示将要（BEFORE）或已经（AFTER）插入的新数据；<br>
> 在 `UPDATE` 型触发器中，`OLD` 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据；<br>
> 在 `DELETE` 型触发器中，`OLD` 用来表示将要或已经被删除的原数据；



## Mysql触发器注意事项

Mysql触发器使用非常简单, 功能也比较有限. 当在项目中大量使用触发器时, 应注意以下几点: <br>

1. Mysql触发器是基于行触发, 而不是一组SQL语句. 因此, 如果需要变动整个数据集而数据集数据量又比较大时, 触发器效果会非常低.
2. 每一个表的一个事件只能定义一个触发器

## Mysql触发器可能导致的问题
对于批量操作并不适合使用触发器, 如: 汇总表, 缓存表等. <br>
触发器使用不当, 可能导致以下问题:
1. 一个触发器可能关联到另外一张表或几张表的操作. 因此, 会导致数据库服务器负荷也会相应的增加一倍或几倍, 如果出现因为触发器问题而导致的性能问题, 会很难定位问题.
2. 在基于锁的操作中, 触发器可能会导致锁等待或死锁. 触发器执行失败, 原来执行的sql语句也会执行失败. 而因为触发器导致的失败结果和失败原因, 往往很难排查

## Mysql触发器的好处
对触发器有足够的认识和了解之后, 能给开发人员带来很大的便利. <br>
当实现一些系统约束时, 或在实现系统维护及针对操作数据的更新时, 使用触发器都非常方便. <br>
在以下场景中, 使用触发器会比较实用:
1. 日志记录. 如: 在用户订单改变至付款或相关状态时, 我们可以基于用户订单数据状态的改变, 使用触发器构建用户订单日志表.
2. 数据汇总. 如: 用户订单成交或失败, 使用触发器构建用户总成交量或失败量汇总数据.